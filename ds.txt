# stack using array
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
#define SIZE 10

void push(int);
void pop();
void display();

int stack[SIZE], top = -1;

void main()
{
int value, choice;
while(1){
printf("\n\n***** MENU *****\n");
printf("1. Push\n2. Pop\n3. Display\n4. Exit");
printf("\nEnter your choice: ");
scanf("%d",&choice);
switch(choice){
case 1: printf("Enter the value to be insert: ");
scanf("%d",&value);
push(value);
break;
case 2: pop();
break;
case 3: display();
break;
case 4: exit(0);
default: printf("\nWrong selection!!! Try again!!!");
}
}
}
void push(int value){
if(top == SIZE-1)
printf("\nStack is Full!!! Insertion is not possible!!!");
else{
top++;
stack[top] = value;
printf("\nInsertion success!!!");
}
}
void pop(){
if(top == -1)
printf("\nStack is Empty!!! Deletion is not possible!!!");
else{
printf("\nDeleted : %d", stack[top]);
top--;
}
}
void display(){
if(top == -1)
printf("\nStack is Empty!!!");
else{
int i;
printf("\nStack elements are:\n");
for(i=top; i>=0; i--)
printf("%d\n",stack[i]);
}
}



//Queues Using Arrays:
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
#define SIZE 10
void enQueue(int);
void deQueue();
void display();
int queue[SIZE], front = -1, rear = -1;
void main()
{
   int value, choice;
   
   while(1){
      printf("\n\n***** MENU *****\n");
      printf("1. Insertion\n2. Deletion\n3. Display\n4. Exit");
      printf("\nEnter your choice: ");
      scanf("%d",&choice);
switch(choice)
{
 case 1: printf("Enter the value to be insert: ");
		 scanf("%d",&value);
		 enQueue(value);
		 break;
 case 2: deQueue();
		 break;
 case 3: display();
		 break;
 case 4:exit(0);
 default: printf("\nWrong selection!!! Try again!!!");
}}}void enQueue(int value){
   if(rear == SIZE-1)
  printf("\nQueue is Full!!! Insertion is not possible!!!");
  else{
      if(front == -1)
	 front = 0;
      rear++;
      queue[rear] = value;
      printf("\nInsertion success!!!");
   }
}
void deQueue(){
   if(front == -1 || front > rear)
      printf("\nQueue is Empty!!! Deletion is not possible!!!");
   else{
      printf("\nDeleted : %d", queue[front]);
      front++;
      if(front > rear)
	 front = rear = -1;
   }
}void display(){
   if(front==-1 || front >rear)
      printf("\nQueue is Empty!!!");
   else{
      int i;
      printf("\nQueue elements are:\n");
      for(i=front; i<=rear; i++)
	  printf("%d\t",queue[i]);
   }
}



stack using link list

include<stdio.h>
#include<conio.h>
#include<stdlib.h>
struct Node
{
   int data;
   struct Node *next;
}
*top = NULL;

void push(int);
void pop();
void display();

void main()
{
   int choice, value;
   
   printf("\n:: Stack using Linked List ::\n");
   while(1){
      printf("\n****** MENU ******\n");
      printf("1. Push\n2. Pop\n3. Display\n4. Exit\n");
      printf("Enter your choice: ");
      scanf("%d",&choice);
      switch(choice){
	 case 1: printf("Enter the value to be insert: ");
		 scanf("%d", &value);
		 push(value);
		 break;
	 case 2: pop(); break;
	 case 3: display(); break;
	 case 4: exit(0);
	 default: printf("\nWrong selection!!! Please try again!!!\n");
      }
   }
}
void push(int value)
{
   struct Node *newNode;
   newNode = (struct Node*)malloc(sizeof(struct Node));
   newNode->data = value;
   if(top == NULL)
      newNode->next = NULL;
   else
      newNode->next = top;
   top = newNode;
   printf("\nInsertion is Success!!!\n");
}
void pop()
{
   if(top == NULL)
      printf("\nStack is Empty!!!\n");
   else{
      struct Node *temp = top;
      printf("\nDeleted element: %d", temp->data);
      top = temp->next;
      free(temp);
   }
}
void display()
{
   if(top == NULL)
      printf("\nStack is Empty!!!\n");
   else{
      struct Node *temp = top;
      while(temp->next != NULL){
	 printf("%d--->",temp->data);
	 temp = temp -> next;
      }
      printf("%d--->NULL",temp->data);
   }
}




Queues Using Linked Lists:
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
struct Node
{
   int data;
   struct Node *next;
}*front = NULL,*rear = NULL;

void insert(int);
void delete();
void display();
void main()
{
   int choice, value;
   printf("\n:: Queue Implementation using Linked List ::\n");
   while(1){
      printf("\n****** MENU ******\n");
      printf("1. Insert\n2. Delete\n3. Display\n4. Exit\n");
      printf("Enter your choice: ");
      scanf("%d",&choice);
switch(choice){
case 1: 
     printf("Enter the value to be insert: ");
	 scanf("%d", &value);
	 insert(value);
	 break;
 case 2: delete(); break;
 case 3: display(); break;
 case 4: exit(0);
 default: printf("\nWrong selection!!! Please try again!!!\n");
      }
   }
}
void insert(int value)
{
   struct Node *newNode;
   newNode = 
	(struct Node*)malloc(sizeof(struct Node));
   newNode->data = value;
   newNode -> next = NULL;
   if(front == NULL)
      front = rear = newNode;
   else
{    rear -> next = newNode;
      rear = newNode;
 }
   printf("\nInsertion is Success!!!\n");}
void delete()
{
   if(front == NULL)
      printf("\nQueue is Empty!!!\n");
   else{
      struct Node *temp = front;
      front = front -> next;
 printf("\nDeleted element: %d\n",
					 temp->data);
      free(temp);
   }
}
void display()
{
   if(front == NULL)
      printf("\nQueue is Empty!!!\n");
   else{
      struct Node *temp = front;
      while(temp->next != NULL)
{
	 printf("%d--->",temp->data);
	 temp = temp -> next;
      }
      printf("%d--->NULL\n",temp->data);
   }}




// Build a Heap from an Array with C

#include <stdio.h>

// swap function

void swap(int *a, int *b)
{
int temp = *b;
*b = *a;
*a = temp;
}


// Function to print the Heap as array

// will print as - 'message array[]\n'

void printArray(char message[], int arr[], int n)
{int i;
printf("%s",message);
for(i = 0; i < n; ++i)
{
printf("%d ",arr[i]);
}
printf("\n");
}


// To heapify a subtree with node i as root

// Size of heap is n

void heapify(int arr[], int n, int i)
{
int largest = i; // Initialize largest as root
int leftChild = 2 * i + 1; // left child = 2*i + 1
int rightChild = 2 * i + 2; // right child = 2*i + 2

// If left child is greater than root

if (leftChild < n && arr[leftChild] > arr[largest])
largest = leftChild;

// If right child is greater than new largest

if (rightChild < n && arr[rightChild] > arr[largest])
largest = rightChild;

// If largest is not the root

if (largest != i)
{
// swap root with the new largest

swap(&arr[i], &arr[largest]);

// Recursively heapify the affected sub-tree i.e, subtree with root as largest
heapify(arr, n, largest);
}
}


// Function to build a Max-Heap from a given array

void buildHeap(int arr[], int n)
{
// Index of last non-leaf node
int lastNonLeafNode = (n / 2) - 1;
int i;
// Perform level order traversal in reverse from last non-leaf node to the root node and heapify each node
for (i = lastNonLeafNode; i >= 0; i--)
{
heapify(arr, n, i);
}
}

void main()
{
// Array
int arr[] = {4, 18, 17, 10, 19, 20, 14, 8, 3, 12};

// Size of array
int n = sizeof(arr) / sizeof(arr[0]);

printArray("Array is : ", arr, n);

buildHeap(arr, n);
printArray("Array representation of Heap is : ", arr, n);
}






// Build a Heap from an Array with C

#include <stdio.h>

// swap function

void swap(int *a, int *b)
{
int temp = *b;
*b = *a;
*a = temp;
}


// Function to print the Heap as array

// will print as - 'message array[]\n'

void printArray(char message[], int arr[], int n)
{int i;
printf("%s",message);
for(i = 0; i < n; ++i)
{
printf("%d ",arr[i]);
}
printf("\n");
}


// To heapify a subtree with node i as root

// Size of heap is n

void heapify(int arr[], int n, int i)
{
int largest = i; // Initialize largest as root
int leftChild = 2 * i + 1; // left child = 2*i + 1
int rightChild = 2 * i + 2; // right child = 2*i + 2

// If left child is greater than root

if (leftChild < n && arr[leftChild] < arr[largest])
largest = leftChild;

// If right child is greater than new largest

if (rightChild < n && arr[rightChild] < arr[largest])
largest = rightChild;

// If largest is not the root

if (largest != i)
{
// swap root with the new largest

swap(&arr[i], &arr[largest]);

// Recursively heapify the affected sub-tree i.e, subtree with root as largest
heapify(arr, n, largest);
}
}


// Function to build a Max-Heap from a given array

void buildHeap(int arr[], int n)
{
// Index of last non-leaf node
int lastNonLeafNode = (n / 2) - 1;
int i;
// Perform level order traversal in reverse from last non-leaf node to the root node and heapify each node
for (i = lastNonLeafNode; i >= 0; i--)
{
heapify(arr, n, i);
}
}


// Driver Code

void main()
{
// Array
int arr[] = {4, 18, 17, 10, 19, 20, 14, 8, 3, 12};

// Size of array
int n = sizeof(arr) / sizeof(arr[0]);

printArray("Array is : ", arr, n);

buildHeap(arr, n);
printArray("Array representation of Heap is : ", arr, n);
}









// Tree traversal in C
#include <stdio.h>
#include <stdlib.h>
struct node {
  int item;
  struct node* left;
  struct node* right;
};
// Inorder traversal

void inorderTraversal(struct node* root) 
{
  if (root == NULL) return;
  inorderTraversal(root->left);
  printf("%d ->", root->item);
  inorderTraversal(root->right);
}
// preorderTraversal traversal

void preorderTraversal(struct node* root)
{
  if (root == NULL) return;
  printf("%d ->", root->item);
  preorderTraversal(root->left);
  preorderTraversal(root->right);
}
// postorderTraversal traversal

void postorderTraversal(struct node* root)
 {
  if (root == NULL) return;
  postorderTraversal(root->left);
  postorderTraversal(root->right);
  printf("%d ->", root->item);
}
// Create a new Node

struct node* createNode(value) 
{
  struct node* newNode = malloc(sizeof(struct node));
  newNode->item = value;
  newNode->left = NULL;
  newNode->right = NULL;
  return newNode;
}
// Insert on the left of the node

struct node* insertLeft(struct node* root, int value) 
{
  root->left = createNode(value);
  return root->left;
}
// Insert on the right of the node

struct node* insertRight(struct node* root, int value) 
{
  root->right = createNode(value);
  return root->right;
}
int main() {
  struct node* root = createNode(1);
  insertLeft(root, 23);
  insertRight(root, 92);

  insertLeft(root->left, 54);
  insertRight(root->left, 64);

  printf("Inorder traversal \n");
  inorderTraversal(root);

  printf("\nPreorder traversal \n");
  preorderTraversal(root);

  printf("\nPostorder traversal \n");
  postorderTraversal(root);
}








//Program to implement Towers of Hanoi
#include <stdio.h>
#include <conio.h>
#include<stdlib.h>
void hanoi(char,char,char,int);
void main()
{
	int num;
	printf("\nENTER NUMBER OF DISKS: ");
	scanf("%d",&num);
	printf("\nTOWER OF HANOI FOR %d NUMBER OF DISKS:\n", num);
	hanoi('A','B','C',num);
	getch();
}
void hanoi(char from,char to,char other,int n)
{
	if(n<=0)
		printf("\nILLEGAL NUMBER OF DISKS");
	if(n==1)
		printf("\nMOVE DISK FROM %c TO %c",from,other);
	if(n>1)
	{
		hanoi(from,other,to,n-1);
		hanoi(from,to,other,1);
		hanoi(to,from,other,n-1);
	}
}








/*  C Program To Check for Balanced Parentheses using Stack*/


#include<stdio.h>
#include<string.h>
#include<stdlib.h>

#define MAX 30
int top=-1;
int stack[MAX];

void push(char);
char pop();
int match(char a,char b);
int check(char []);

int main()
{
        char exp[MAX];
        int valid;
        printf("Enter an algebraic expression : ");
        gets(exp);
        valid=check(exp);
        if(valid==1)
                printf("Valid expression\n");
        else
                printf("Invalid expression\n");

                return 0;

}
int check(char exp[] )
{
        int i;
        char temp;
        for(i=0;i<strlen(exp);i++)
        {
                if(exp[i]=='(' || exp[i]=='{' || exp[i]=='[')
                        push(exp[i]);
                if(exp[i]==')' || exp[i]=='}' || exp[i]==']')
                        if(top==-1)    /*stack empty*/
                        {
                                printf("Right parentheses are more than left parentheses\n");
                                return 0;
                        }
                        else
                        {
                                temp=pop();
                                if(!match(temp, exp[i]))
                                {
                                        printf("Mismatched parentheses are : ");
                                        printf("%c and %c\n",temp,exp[i]);
                                        return 0;
                                }
                        }
        }
        if(top==-1) /*stack empty*/
        {
                printf("Balanced Parentheses\n");
                return 1;
        }
        else
        {
                printf("Left parentheses more than right parentheses\n");
                return 0;
        }
}/*End of main()*/
int match(char a,char b)
{
        if(a=='[' && b==']')
                return 1;
        if(a=='{' && b=='}')
                return 1;
        if(a=='(' && b==')')
                return 1;
        return 0;
}/*End of match()*/

void push(char item)
{
        if(top==(MAX-1))
        {
                printf("Stack Overflow\n");
                return;
        }
        top=top+1;
        stack[top]=item;
}/*End of push()*/

char pop()
{
        if(top==-1)
        {
                printf("Stack Underflow\n");
                exit(1);
        }
        return(stack[top--]);
}/*End of pop()*/

